{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "22de77a4",
   "metadata": {},
   "source": [
    "# **Código Datos por metrópoli**\n",
    "Esto será el código para cargar la información a postgreSQL y extraer estadísticas de todas las metrópolis. <br>\n",
    "<br>\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "da9ed588",
   "metadata": {},
   "outputs": [],
   "source": [
    "import geopandas as gpd\n",
    "from sqlalchemy import create_engine\n",
    "import os\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from shapely.geometry import Polygon\n",
    "from dbfread import DBF\n",
    "import jenkspy\n",
    "import json\n",
    "from jenkspy import jenks_breaks\n",
    "import psycopg2\n",
    "import openpyxl"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c2afaf81",
   "metadata": {},
   "source": [
    "# Estadísticas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "bc72db0f",
   "metadata": {},
   "outputs": [],
   "source": [
    "MAPA_TIPO_ruta = r\"C:\\Users\\ADMIN\\OneDrive - Universidad de Guadalajara\\3. Voces\\2024\\Tipologías\\Nacional\\240527_Mapa_Subtipologías_PCU.gpkg\"\n",
    "\n",
    "# Leer gpkg base\n",
    "MAPA_TIPO_gdf = gpd.read_file(MAPA_TIPO_ruta, layer='Mapa_SubTipologias_PCUS')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f8cfb3f3",
   "metadata": {},
   "source": [
    "# Resultados por Metrópoli y Tipología"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "fe214dba",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Columnas que se sumarán\n",
    "columnas_a_sumar = ['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'VIVPARDES2010',\n",
    "       'VIVPARDES2020', 'VIV1C2010', 'VIV1C2020', 'VIV2C2010', 'VIV2C2020',\n",
    "       'VIV3CYM2010', 'VIV3CYM2020','area_ha']\n",
    "\n",
    "# Sumar las columnas y agrupar por 'TIPOLOGIA' y 'NOM_MET'\n",
    "MAPA_TIPO_sumado = MAPA_TIPO_gdf.groupby(['TIPOLOGIA', 'NOM_MET','TIPO_MET'])[columnas_a_sumar].sum().reset_index()\n",
    "\n",
    "# Contar las manzanas agrupadas\n",
    "MAPA_TIPO_sumado['Manzanas'] = MAPA_TIPO_gdf.groupby(['TIPOLOGIA', 'NOM_MET','TIPO_MET']).size().values\n",
    "\n",
    "# Calcular los campos\n",
    "MAPA_TIPO_sumado['DIFPOP'] = MAPA_TIPO_sumado['POPTOT2020'] - MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['DIFVIV'] = MAPA_TIPO_sumado['VIVTOT2020'] - MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['RELPOP'] = MAPA_TIPO_sumado['DIFPOP'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['RELVIV'] = MAPA_TIPO_sumado['DIFVIV'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['CVEPOP'] = np.where(MAPA_TIPO_sumado['RELPOP'] < -0.000000001, 'A', 'B')\n",
    "MAPA_TIPO_sumado['CVEVIV'] = np.where(MAPA_TIPO_sumado['RELVIV'] < -.0703, '1',\n",
    "                                   np.where((MAPA_TIPO_sumado['RELVIV'] >= -.0703) & (MAPA_TIPO_sumado['RELVIV'] <= .0703), \n",
    "                                            '2', '3'))\n",
    "MAPA_TIPO_sumado['CVE'] = MAPA_TIPO_sumado['CVEPOP'] + MAPA_TIPO_sumado['CVEVIV'].astype(str)\n",
    "\n",
    "conditions = [\n",
    "    (MAPA_TIPO_sumado['POPTOT2020'] == 0),\n",
    "    (MAPA_TIPO_sumado['POPTOT2010'] == 0) & (MAPA_TIPO_sumado['VIVTOT2010'] == 0) & (MAPA_TIPO_sumado['CVE'] == 'B3')\n",
    "]\n",
    "choices = ['DH', 'B3\\'']\n",
    "MAPA_TIPO_sumado['TIPOLOGIA'] = np.select(conditions, choices, default=MAPA_TIPO_sumado['CVE'])\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_POP10'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_POP20'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_VIV10'] = MAPA_TIPO_sumado['VIVTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_VIV20'] = MAPA_TIPO_sumado['VIVTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['CUARTOS2010'] = ((MAPA_TIPO_sumado['VIV1C2010']*1) + (MAPA_TIPO_sumado['VIV1C2010']*2) + (MAPA_TIPO_sumado['VIV3CYM2010']*4))\n",
    "MAPA_TIPO_sumado['CUARTOS2020'] = ((MAPA_TIPO_sumado['VIV1C2020']*1) + (MAPA_TIPO_sumado['VIV1C2020']*2) + (MAPA_TIPO_sumado['VIV3CYM2020']*4))\n",
    "\n",
    "MAPA_TIPO_sumado['CPERC2010'] = MAPA_TIPO_sumado['CUARTOS2010'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['CPERC2020'] = MAPA_TIPO_sumado['CUARTOS2020'] / MAPA_TIPO_sumado['POPTOT2020']\n",
    "\n",
    "MAPA_TIPO_sumado['HABXVIV2010'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['HABXVIV2020'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "MAPA_TIPO_sumado['DESHABITACION'] = MAPA_TIPO_sumado['VIVPARDES2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "\n",
    "# Calcular TASA_POP_MUN\n",
    "MAPA_TIPO_sumado['TASA_POP'] = (((MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['POPTOT2010']) ** (1/10)) - 1) * 100\n",
    "\n",
    "def asignar_subtipologia(row):\n",
    "    # Valores específicos para deshabitación\n",
    "    rangos_deshabitacion_grupo = [0, .0703, .1416, .2812]  # Modifica estos valores según tus necesidades\n",
    "    \n",
    "    # Asignar subtipología según los rangos definidos\n",
    "    if rangos_deshabitacion_grupo[0] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[1]:\n",
    "        return 'a'\n",
    "    elif rangos_deshabitacion_grupo[1] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[2]:\n",
    "        return 'b'\n",
    "    elif rangos_deshabitacion_grupo[2] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[3]:\n",
    "        return 'c'\n",
    "    elif row['DESHABITACION'] >= rangos_deshabitacion_grupo[3]:\n",
    "        return 'd'\n",
    "    else:\n",
    "        return '0'  # Valor predeterminado\n",
    "\n",
    "# Crear un nuevo campo 'R_DESHAB' y llenarlo con las subtipologías asignadas\n",
    "MAPA_TIPO_sumado['R_DESHAB'] = MAPA_TIPO_sumado.apply(asignar_subtipologia, axis=1)\n",
    "\n",
    "# Crear el campo SUBTIPOLOGÍA\n",
    "MAPA_TIPO_sumado['SUBTIPOLOGÍA'] = MAPA_TIPO_sumado['TIPOLOGIA'].astype(str) + '-' + MAPA_TIPO_sumado['R_DESHAB'].astype(str)\n",
    "\n",
    "# Calcular los totales por Metrópoli\n",
    "totales_metro = MAPA_TIPO_sumado.groupby('NOM_MET')[['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'area_ha', 'Manzanas']].transform('sum')\n",
    "\n",
    "# Calcular el porcentaje para cada campo\n",
    "MAPA_TIPO_sumado['PCT_POPTOT2010'] = (MAPA_TIPO_sumado['POPTOT2010'] / totales_metro['POPTOT2010']) * 100\n",
    "MAPA_TIPO_sumado['PCT_POPTOT2020'] = (MAPA_TIPO_sumado['POPTOT2020'] / totales_metro['POPTOT2020']) * 100\n",
    "MAPA_TIPO_sumado['PCT_VIVTOT2010'] = (MAPA_TIPO_sumado['VIVTOT2010'] / totales_metro['VIVTOT2010']) * 100\n",
    "MAPA_TIPO_sumado['PCT_VIVTOT2020'] = (MAPA_TIPO_sumado['VIVTOT2020'] / totales_metro['VIVTOT2020']) * 100\n",
    "MAPA_TIPO_sumado['PCT_AREA_HA'] = (MAPA_TIPO_sumado['area_ha'] / totales_metro['area_ha']) * 100\n",
    "MAPA_TIPO_sumado['PCT_MANZANAS'] = (MAPA_TIPO_sumado['Manzanas'] / totales_metro['Manzanas']) * 100\n",
    "\n",
    "# Guardar los datos en un archivo Excel\n",
    "MAPA_TIPO_sumado.to_excel('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_tipologias.xlsx', index=False)\n",
    "\n",
    "# Leer el archivo Excel\n",
    "wb = openpyxl.load_workbook('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_tipologias.xlsx')\n",
    "\n",
    "# Seleccionar la hoja de cálculo\n",
    "sheet = wb.active\n",
    "\n",
    "# Ajustar el ancho de las columnas automáticamente\n",
    "for col in sheet.columns:\n",
    "    max_length = 0\n",
    "    column = col[0].column_letter\n",
    "    for cell in col:\n",
    "        try:\n",
    "            if len(str(cell.value)) > max_length:\n",
    "                max_length = len(cell.value)\n",
    "        except:\n",
    "            pass\n",
    "    adjusted_width = (max_length + 2) * 1.2\n",
    "    sheet.column_dimensions[column].width = adjusted_width\n",
    "\n",
    "# Guardar los cambios en el archivo Excel\n",
    "wb.save('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_tipologias_v2.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87392006-c457-4093-911a-f42d7fe477d3",
   "metadata": {},
   "source": [
    "# Resultados por Municipio y Tipología"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "35e0419d-e1c6-417a-9d5b-17e57324a191",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Columnas que se sumarán\n",
    "columnas_a_sumar = ['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'VIVPARDES2010',\n",
    "       'VIVPARDES2020', 'VIV1C2010', 'VIV1C2020', 'VIV2C2010', 'VIV2C2020',\n",
    "       'VIV3CYM2010', 'VIV3CYM2020','area_ha']\n",
    "\n",
    "# Sumar las columnas y agrupar por 'TIPOLOGIA' y 'NOM_MET'\n",
    "MAPA_TIPO_sumado = MAPA_TIPO_gdf.groupby(['TIPOLOGIA', 'CVEMUN', 'NOM_MET','TIPO_MET'])[columnas_a_sumar].sum().reset_index()\n",
    "\n",
    "# Contar las manzanas agrupadas\n",
    "MAPA_TIPO_sumado['Manzanas'] = MAPA_TIPO_gdf.groupby(['TIPOLOGIA', 'CVEMUN', 'NOM_MET','TIPO_MET']).size().values\n",
    "\n",
    "# Calcular los campos\n",
    "MAPA_TIPO_sumado['DIFPOP'] = MAPA_TIPO_sumado['POPTOT2020'] - MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['DIFVIV'] = MAPA_TIPO_sumado['VIVTOT2020'] - MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['RELPOP'] = MAPA_TIPO_sumado['DIFPOP'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['RELVIV'] = MAPA_TIPO_sumado['DIFVIV'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['CVEPOP'] = np.where(MAPA_TIPO_sumado['RELPOP'] < -0.000000001, 'A', 'B')\n",
    "MAPA_TIPO_sumado['CVEVIV'] = np.where(MAPA_TIPO_sumado['RELVIV'] < -.0703, '1',\n",
    "                                   np.where((MAPA_TIPO_sumado['RELVIV'] >= -.0703) & (MAPA_TIPO_sumado['RELVIV'] <= .0703), \n",
    "                                            '2', '3'))\n",
    "MAPA_TIPO_sumado['CVE'] = MAPA_TIPO_sumado['CVEPOP'] + MAPA_TIPO_sumado['CVEVIV'].astype(str)\n",
    "\n",
    "conditions = [\n",
    "    (MAPA_TIPO_sumado['POPTOT2020'] == 0),\n",
    "    (MAPA_TIPO_sumado['POPTOT2010'] == 0) & (MAPA_TIPO_sumado['VIVTOT2010'] == 0) & (MAPA_TIPO_sumado['CVE'] == 'B3')\n",
    "]\n",
    "choices = ['DH', 'B3\\'']\n",
    "MAPA_TIPO_sumado['TIPOLOGIA'] = np.select(conditions, choices, default=MAPA_TIPO_sumado['CVE'])\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_POP10'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_POP20'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_VIV10'] = MAPA_TIPO_sumado['VIVTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_VIV20'] = MAPA_TIPO_sumado['VIVTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['CUARTOS2010'] = ((MAPA_TIPO_sumado['VIV1C2010']*1) + (MAPA_TIPO_sumado['VIV1C2010']*2) + (MAPA_TIPO_sumado['VIV3CYM2010']*4))\n",
    "MAPA_TIPO_sumado['CUARTOS2020'] = ((MAPA_TIPO_sumado['VIV1C2020']*1) + (MAPA_TIPO_sumado['VIV1C2020']*2) + (MAPA_TIPO_sumado['VIV3CYM2020']*4))\n",
    "\n",
    "MAPA_TIPO_sumado['CPERC2010'] = MAPA_TIPO_sumado['CUARTOS2010'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['CPERC2020'] = MAPA_TIPO_sumado['CUARTOS2020'] / MAPA_TIPO_sumado['POPTOT2020']\n",
    "\n",
    "MAPA_TIPO_sumado['HABXVIV2010'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['HABXVIV2020'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "MAPA_TIPO_sumado['DESHABITACION'] = MAPA_TIPO_sumado['VIVPARDES2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "\n",
    "# Calcular TASA_POP_MUN\n",
    "MAPA_TIPO_sumado['TASA_POP'] = (((MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['POPTOT2010']) ** (1/10)) - 1) * 100\n",
    "\n",
    "def asignar_subtipologia(row):\n",
    "    # Valores específicos para deshabitación\n",
    "    rangos_deshabitacion_grupo = [0, .0703, .1416, .2812]  # Modifica estos valores según tus necesidades\n",
    "    \n",
    "    # Asignar subtipología según los rangos definidos\n",
    "    if rangos_deshabitacion_grupo[0] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[1]:\n",
    "        return 'a'\n",
    "    elif rangos_deshabitacion_grupo[1] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[2]:\n",
    "        return 'b'\n",
    "    elif rangos_deshabitacion_grupo[2] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[3]:\n",
    "        return 'c'\n",
    "    elif row['DESHABITACION'] >= rangos_deshabitacion_grupo[3]:\n",
    "        return 'd'\n",
    "    else:\n",
    "        return '0'  # Valor predeterminado\n",
    "\n",
    "# Crear un nuevo campo 'R_DESHAB' y llenarlo con las subtipologías asignadas\n",
    "MAPA_TIPO_sumado['R_DESHAB'] = MAPA_TIPO_sumado.apply(asignar_subtipologia, axis=1)\n",
    "\n",
    "# Crear el campo SUBTIPOLOGÍA\n",
    "MAPA_TIPO_sumado['SUBTIPOLOGÍA'] = MAPA_TIPO_sumado['TIPOLOGIA'].astype(str) + '-' + MAPA_TIPO_sumado['R_DESHAB'].astype(str)\n",
    "\n",
    "# Calcular los totales por Metrópoli\n",
    "totales_metro = MAPA_TIPO_sumado.groupby('NOM_MET')[['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'area_ha', 'Manzanas']].transform('sum')\n",
    "\n",
    "# Calcular el porcentaje para cada campo\n",
    "MAPA_TIPO_sumado['PCT_POPTOT2010'] = (MAPA_TIPO_sumado['POPTOT2010'] / totales_metro['POPTOT2010']) * 100\n",
    "MAPA_TIPO_sumado['PCT_POPTOT2020'] = (MAPA_TIPO_sumado['POPTOT2020'] / totales_metro['POPTOT2020']) * 100\n",
    "MAPA_TIPO_sumado['PCT_VIVTOT2010'] = (MAPA_TIPO_sumado['VIVTOT2010'] / totales_metro['VIVTOT2010']) * 100\n",
    "MAPA_TIPO_sumado['PCT_VIVTOT2020'] = (MAPA_TIPO_sumado['VIVTOT2020'] / totales_metro['VIVTOT2020']) * 100\n",
    "MAPA_TIPO_sumado['PCT_AREA_HA'] = (MAPA_TIPO_sumado['area_ha'] / totales_metro['area_ha']) * 100\n",
    "MAPA_TIPO_sumado['PCT_MANZANAS'] = (MAPA_TIPO_sumado['Manzanas'] / totales_metro['Manzanas']) * 100\n",
    "\n",
    "# Guardar los datos en un archivo Excel\n",
    "MAPA_TIPO_sumado.to_excel('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_municipios.xlsx', index=False)\n",
    "\n",
    "# Leer el archivo Excel\n",
    "wb = openpyxl.load_workbook('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_municipios.xlsx')\n",
    "\n",
    "# Seleccionar la hoja de cálculo\n",
    "sheet = wb.active\n",
    "\n",
    "# Ajustar el ancho de las columnas automáticamente\n",
    "for col in sheet.columns:\n",
    "    max_length = 0\n",
    "    column = col[0].column_letter\n",
    "    for cell in col:\n",
    "        try:\n",
    "            if len(str(cell.value)) > max_length:\n",
    "                max_length = len(cell.value)\n",
    "        except:\n",
    "            pass\n",
    "    adjusted_width = (max_length + 2) * 1.2\n",
    "    sheet.column_dimensions[column].width = adjusted_width\n",
    "\n",
    "# Guardar los cambios en el archivo Excel\n",
    "wb.save('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_municipios_v2.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8688e11b",
   "metadata": {},
   "source": [
    "# Resultados por Metrópoli y Deshabitación"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "d45de168",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Columnas que se sumarán\n",
    "columnas_a_sumar = ['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'VIVPARDES2010',\n",
    "       'VIVPARDES2020', 'VIV1C2010', 'VIV1C2020', 'VIV2C2010', 'VIV2C2020',\n",
    "       'VIV3CYM2010', 'VIV3CYM2020','area_ha']\n",
    "\n",
    "# Sumar las columnas y agrupar por 'TIPOLOGIA' y 'NOM_MET'\n",
    "MAPA_TIPO_sumado = MAPA_TIPO_gdf.groupby(['R_DESHAB', 'NOM_MET', 'TIPO_MET'])[columnas_a_sumar].sum().reset_index()\n",
    "\n",
    "# Contar las manzanas agrupadas\n",
    "MAPA_TIPO_sumado['Manzanas'] = MAPA_TIPO_gdf.groupby(['R_DESHAB', 'NOM_MET','TIPO_MET']).size().values\n",
    "\n",
    "# Calcular los campos\n",
    "MAPA_TIPO_sumado['DIFPOP'] = MAPA_TIPO_sumado['POPTOT2020'] - MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['DIFVIV'] = MAPA_TIPO_sumado['VIVTOT2020'] - MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['RELPOP'] = MAPA_TIPO_sumado['DIFPOP'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['RELVIV'] = MAPA_TIPO_sumado['DIFVIV'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['CVEPOP'] = np.where(MAPA_TIPO_sumado['RELPOP'] < -0.000000001, 'A', 'B')\n",
    "MAPA_TIPO_sumado['CVEVIV'] = np.where(MAPA_TIPO_sumado['RELVIV'] < -.0703, '1',\n",
    "                                   np.where((MAPA_TIPO_sumado['RELVIV'] >= -.0703) & (MAPA_TIPO_sumado['RELVIV'] <= .0703), \n",
    "                                            '2', '3'))\n",
    "MAPA_TIPO_sumado['CVE'] = MAPA_TIPO_sumado['CVEPOP'] + MAPA_TIPO_sumado['CVEVIV'].astype(str)\n",
    "\n",
    "conditions = [\n",
    "    (MAPA_TIPO_sumado['POPTOT2020'] == 0),\n",
    "    (MAPA_TIPO_sumado['POPTOT2010'] == 0) & (MAPA_TIPO_sumado['VIVTOT2010'] == 0) & (MAPA_TIPO_sumado['CVE'] == 'B3')\n",
    "]\n",
    "choices = ['DH', 'B3\\'']\n",
    "MAPA_TIPO_sumado['TIPOLOGIA'] = np.select(conditions, choices, default=MAPA_TIPO_sumado['CVE'])\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_POP10'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_POP20'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_VIV10'] = MAPA_TIPO_sumado['VIVTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_VIV20'] = MAPA_TIPO_sumado['VIVTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['CUARTOS2010'] = ((MAPA_TIPO_sumado['VIV1C2010']*1) + (MAPA_TIPO_sumado['VIV1C2010']*2) + (MAPA_TIPO_sumado['VIV3CYM2010']*4))\n",
    "MAPA_TIPO_sumado['CUARTOS2020'] = ((MAPA_TIPO_sumado['VIV1C2020']*1) + (MAPA_TIPO_sumado['VIV1C2020']*2) + (MAPA_TIPO_sumado['VIV3CYM2020']*4))\n",
    "\n",
    "MAPA_TIPO_sumado['CPERC2010'] = MAPA_TIPO_sumado['CUARTOS2010'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['CPERC2020'] = MAPA_TIPO_sumado['CUARTOS2020'] / MAPA_TIPO_sumado['POPTOT2020']\n",
    "\n",
    "MAPA_TIPO_sumado['HABXVIV2010'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['HABXVIV2020'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "MAPA_TIPO_sumado['DESHABITACION'] = MAPA_TIPO_sumado['VIVPARDES2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "\n",
    "# Calcular TASA_POP_MUN\n",
    "MAPA_TIPO_sumado['TASA_POP'] = (((MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['POPTOT2010']) ** (1/10)) - 1) * 100\n",
    "\n",
    "def asignar_subtipologia(row):\n",
    "    # Valores específicos para deshabitación\n",
    "    rangos_deshabitacion_grupo = [0, .0703, .1416, .2812]  # Modifica estos valores según tus necesidades\n",
    "    \n",
    "    # Asignar subtipología según los rangos definidos\n",
    "    if rangos_deshabitacion_grupo[0] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[1]:\n",
    "        return 'a'\n",
    "    elif rangos_deshabitacion_grupo[1] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[2]:\n",
    "        return 'b'\n",
    "    elif rangos_deshabitacion_grupo[2] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[3]:\n",
    "        return 'c'\n",
    "    elif row['DESHABITACION'] >= rangos_deshabitacion_grupo[3]:\n",
    "        return 'd'\n",
    "    else:\n",
    "        return '0'  # Valor predeterminado\n",
    "\n",
    "# Crear un nuevo campo 'R_DESHAB' y llenarlo con las subtipologías asignadas\n",
    "MAPA_TIPO_sumado['R_DESHAB'] = MAPA_TIPO_sumado.apply(asignar_subtipologia, axis=1)\n",
    "\n",
    "# Crear el campo SUBTIPOLOGÍA\n",
    "MAPA_TIPO_sumado['SUBTIPOLOGÍA'] = MAPA_TIPO_sumado['TIPOLOGIA'].astype(str) + '-' + MAPA_TIPO_sumado['R_DESHAB'].astype(str)\n",
    "\n",
    "# Guardar los datos en un archivo Excel\n",
    "MAPA_TIPO_sumado.to_excel('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_deshabitacion.xlsx', index=False)\n",
    "\n",
    "# Leer el archivo Excel\n",
    "wb = openpyxl.load_workbook('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_deshabitacion.xlsx')\n",
    "\n",
    "# Seleccionar la hoja de cálculo\n",
    "sheet = wb.active\n",
    "\n",
    "# Ajustar el ancho de las columnas automáticamente\n",
    "for col in sheet.columns:\n",
    "    max_length = 0\n",
    "    column = col[0].column_letter\n",
    "    for cell in col:\n",
    "        try:\n",
    "            if len(str(cell.value)) > max_length:\n",
    "                max_length = len(cell.value)\n",
    "        except:\n",
    "            pass\n",
    "    adjusted_width = (max_length + 2) * 1.2\n",
    "    sheet.column_dimensions[column].width = adjusted_width\n",
    "\n",
    "# Guardar los cambios en el archivo Excel\n",
    "wb.save('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_deshabitacion_v2.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee107221",
   "metadata": {},
   "source": [
    "# Resultados por Metrópoli"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "f3a8982d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Columnas que se sumarán\n",
    "columnas_a_sumar = ['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'VIVPARDES2010',\n",
    "       'VIVPARDES2020', 'VIV1C2010', 'VIV1C2020', 'VIV2C2010', 'VIV2C2020',\n",
    "       'VIV3CYM2010', 'VIV3CYM2020','area_ha']\n",
    "\n",
    "# Sumar las columnas y agrupar por 'NOM_MET'\n",
    "MAPA_TIPO_sumado = MAPA_TIPO_gdf.groupby(['NOM_MET','TIPO_MET'])[columnas_a_sumar].sum().reset_index()\n",
    "\n",
    "# Contar las manzanas agrupadas\n",
    "MAPA_TIPO_sumado['Manzanas'] = MAPA_TIPO_gdf.groupby(['NOM_MET','TIPO_MET']).size().values\n",
    "\n",
    "# Recalcular los campos\n",
    "MAPA_TIPO_sumado['DIFPOP'] = MAPA_TIPO_sumado['POPTOT2020'] - MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['DIFVIV'] = MAPA_TIPO_sumado['VIVTOT2020'] - MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['RELPOP'] = MAPA_TIPO_sumado['DIFPOP'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['RELVIV'] = MAPA_TIPO_sumado['DIFVIV'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['CVEPOP'] = np.where(MAPA_TIPO_sumado['RELPOP'] < -0.000000001, 'A', 'B')\n",
    "MAPA_TIPO_sumado['CVEVIV'] = np.where(MAPA_TIPO_sumado['RELVIV'] < -.0703, '1',\n",
    "                                   np.where((MAPA_TIPO_sumado['RELVIV'] >= -.0703) & (MAPA_TIPO_sumado['RELVIV'] <= .0703), \n",
    "                                            '2', '3'))\n",
    "MAPA_TIPO_sumado['CVE'] = MAPA_TIPO_sumado['CVEPOP'] + MAPA_TIPO_sumado['CVEVIV'].astype(str)\n",
    "\n",
    "conditions = [\n",
    "    (MAPA_TIPO_sumado['POPTOT2020'] == 0),\n",
    "    (MAPA_TIPO_sumado['POPTOT2010'] == 0) & (MAPA_TIPO_sumado['VIVTOT2010'] == 0) & (MAPA_TIPO_sumado['CVE'] == 'B3')\n",
    "]\n",
    "choices = ['DH', 'B3\\'']\n",
    "MAPA_TIPO_sumado['TIPOLOGIA'] = np.select(conditions, choices, default=MAPA_TIPO_sumado['CVE'])\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_POP10'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_POP20'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_VIV10'] = MAPA_TIPO_sumado['VIVTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_VIV20'] = MAPA_TIPO_sumado['VIVTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['CUARTOS2010'] = ((MAPA_TIPO_sumado['VIV1C2010']*1) + (MAPA_TIPO_sumado['VIV1C2010']*2) + (MAPA_TIPO_sumado['VIV3CYM2010']*4))\n",
    "MAPA_TIPO_sumado['CUARTOS2020'] = ((MAPA_TIPO_sumado['VIV1C2020']*1) + (MAPA_TIPO_sumado['VIV1C2020']*2) + (MAPA_TIPO_sumado['VIV3CYM2020']*4))\n",
    "\n",
    "MAPA_TIPO_sumado['CPERC2010'] = MAPA_TIPO_sumado['CUARTOS2010'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['CPERC2020'] = MAPA_TIPO_sumado['CUARTOS2020'] / MAPA_TIPO_sumado['POPTOT2020']\n",
    "\n",
    "MAPA_TIPO_sumado['HABXVIV2010'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['HABXVIV2020'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "MAPA_TIPO_sumado['DESHABITACION'] = MAPA_TIPO_sumado['VIVPARDES2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "\n",
    "# Calcular TASA_POP_MUN\n",
    "MAPA_TIPO_sumado['TASA_POP'] = (((MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['POPTOT2010']) ** (1/10)) - 1) * 100\n",
    "\n",
    "def asignar_subtipologia(row):\n",
    "    # Valores específicos para deshabitación\n",
    "    rangos_deshabitacion_grupo = [0, .0703, .1416, .2812]  # Modifica estos valores según tus necesidades\n",
    "    \n",
    "    # Asignar subtipología según los rangos definidos\n",
    "    if rangos_deshabitacion_grupo[0] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[1]:\n",
    "        return 'a'\n",
    "    elif rangos_deshabitacion_grupo[1] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[2]:\n",
    "        return 'b'\n",
    "    elif rangos_deshabitacion_grupo[2] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[3]:\n",
    "        return 'c'\n",
    "    elif row['DESHABITACION'] >= rangos_deshabitacion_grupo[3]:\n",
    "        return 'd'\n",
    "    else:\n",
    "        return '0'  # Valor predeterminado\n",
    "\n",
    "# Crear un nuevo campo 'R_DESHAB' y llenarlo con las subtipologías asignadas\n",
    "MAPA_TIPO_sumado['R_DESHAB'] = MAPA_TIPO_sumado.apply(asignar_subtipologia, axis=1)\n",
    "\n",
    "# Crear el campo SUBTIPOLOGÍA\n",
    "MAPA_TIPO_sumado['SUBTIPOLOGÍA'] = MAPA_TIPO_sumado['TIPOLOGIA'].astype(str) + '-' + MAPA_TIPO_sumado['R_DESHAB'].astype(str)\n",
    "\n",
    "\n",
    "# Guardar los datos en un archivo Excel\n",
    "MAPA_TIPO_sumado.to_excel('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_metropoli.xlsx', index=False)\n",
    "\n",
    "# Leer el archivo Excel\n",
    "wb = openpyxl.load_workbook('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_metropoli.xlsx')\n",
    "\n",
    "# Seleccionar la hoja de cálculo\n",
    "sheet = wb.active\n",
    "\n",
    "# Ajustar el ancho de las columnas automáticamente\n",
    "for col in sheet.columns:\n",
    "    max_length = 0\n",
    "    column = col[0].column_letter\n",
    "    for cell in col:\n",
    "        try:\n",
    "            if len(str(cell.value)) > max_length:\n",
    "                max_length = len(cell.value)\n",
    "        except:\n",
    "            pass\n",
    "    adjusted_width = (max_length + 2) * 1.2\n",
    "    sheet.column_dimensions[column].width = adjusted_width\n",
    "\n",
    "# Guardar los cambios en el archivo Excel\n",
    "wb.save('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_metropoli_v2.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1ad6e30f",
   "metadata": {},
   "source": [
    "# Resultados por Municipio"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "cb32c206",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Columnas que se sumarán\n",
    "columnas_a_sumar = ['POPTOT2010', 'POPTOT2020', 'VIVTOT2010', 'VIVTOT2020', 'VIVPARDES2010',\n",
    "       'VIVPARDES2020', 'VIV1C2010', 'VIV1C2020', 'VIV2C2010', 'VIV2C2020',\n",
    "       'VIV3CYM2010', 'VIV3CYM2020','area_ha']\n",
    "\n",
    "# Sumar las columnas y agrupar por 'NOM_MET'\n",
    "MAPA_TIPO_sumado = MAPA_TIPO_gdf.groupby(['CVEMUN', 'NOM_MET','TIPO_MET'])[columnas_a_sumar].sum().reset_index()\n",
    "\n",
    "# Contar las manzanas agrupadas\n",
    "MAPA_TIPO_sumado['Manzanas'] = MAPA_TIPO_gdf.groupby(['CVEMUN', 'NOM_MET','TIPO_MET']).size().values\n",
    "\n",
    "# Recalcular los campos\n",
    "MAPA_TIPO_sumado['DIFPOP'] = MAPA_TIPO_sumado['POPTOT2020'] - MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['DIFVIV'] = MAPA_TIPO_sumado['VIVTOT2020'] - MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['RELPOP'] = MAPA_TIPO_sumado['DIFPOP'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['RELVIV'] = MAPA_TIPO_sumado['DIFVIV'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['CVEPOP'] = np.where(MAPA_TIPO_sumado['RELPOP'] < -0.000000001, 'A', 'B')\n",
    "MAPA_TIPO_sumado['CVEVIV'] = np.where(MAPA_TIPO_sumado['RELVIV'] < -.0703, '1',\n",
    "                                   np.where((MAPA_TIPO_sumado['RELVIV'] >= -.0703) & (MAPA_TIPO_sumado['RELVIV'] <= .0703), \n",
    "                                            '2', '3'))\n",
    "MAPA_TIPO_sumado['CVE'] = MAPA_TIPO_sumado['CVEPOP'] + MAPA_TIPO_sumado['CVEVIV'].astype(str)\n",
    "\n",
    "conditions = [\n",
    "    (MAPA_TIPO_sumado['POPTOT2020'] == 0),\n",
    "    (MAPA_TIPO_sumado['POPTOT2010'] == 0) & (MAPA_TIPO_sumado['VIVTOT2010'] == 0) & (MAPA_TIPO_sumado['CVE'] == 'B3')\n",
    "]\n",
    "choices = ['DH', 'B3\\'']\n",
    "MAPA_TIPO_sumado['TIPOLOGIA'] = np.select(conditions, choices, default=MAPA_TIPO_sumado['CVE'])\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_POP10'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_POP20'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['DENS_VIV10'] = MAPA_TIPO_sumado['VIVTOT2010'] / MAPA_TIPO_sumado['area_ha']\n",
    "MAPA_TIPO_sumado['DENS_VIV20'] = MAPA_TIPO_sumado['VIVTOT2020'] / MAPA_TIPO_sumado['area_ha']\n",
    "\n",
    "MAPA_TIPO_sumado['CUARTOS2010'] = ((MAPA_TIPO_sumado['VIV1C2010']*1) + (MAPA_TIPO_sumado['VIV1C2010']*2) + (MAPA_TIPO_sumado['VIV3CYM2010']*4))\n",
    "MAPA_TIPO_sumado['CUARTOS2020'] = ((MAPA_TIPO_sumado['VIV1C2020']*1) + (MAPA_TIPO_sumado['VIV1C2020']*2) + (MAPA_TIPO_sumado['VIV3CYM2020']*4))\n",
    "\n",
    "MAPA_TIPO_sumado['CPERC2010'] = MAPA_TIPO_sumado['CUARTOS2010'] / MAPA_TIPO_sumado['POPTOT2010']\n",
    "MAPA_TIPO_sumado['CPERC2020'] = MAPA_TIPO_sumado['CUARTOS2020'] / MAPA_TIPO_sumado['POPTOT2020']\n",
    "\n",
    "MAPA_TIPO_sumado['HABXVIV2010'] = MAPA_TIPO_sumado['POPTOT2010'] / MAPA_TIPO_sumado['VIVTOT2010']\n",
    "MAPA_TIPO_sumado['HABXVIV2020'] = MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "MAPA_TIPO_sumado['DESHABITACION'] = MAPA_TIPO_sumado['VIVPARDES2020'] / MAPA_TIPO_sumado['VIVTOT2020']\n",
    "\n",
    "# Calcular TASA_POP_MUN\n",
    "MAPA_TIPO_sumado['TASA_POP'] = (((MAPA_TIPO_sumado['POPTOT2020'] / MAPA_TIPO_sumado['POPTOT2010']) ** (1/10)) - 1) * 100\n",
    "\n",
    "def asignar_subtipologia(row):\n",
    "    # Valores específicos para deshabitación\n",
    "    rangos_deshabitacion_grupo = [0, .0703, .1416, .2812]  # Modifica estos valores según tus necesidades\n",
    "    \n",
    "    # Asignar subtipología según los rangos definidos\n",
    "    if rangos_deshabitacion_grupo[0] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[1]:\n",
    "        return 'a'\n",
    "    elif rangos_deshabitacion_grupo[1] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[2]:\n",
    "        return 'b'\n",
    "    elif rangos_deshabitacion_grupo[2] <= row['DESHABITACION'] < rangos_deshabitacion_grupo[3]:\n",
    "        return 'c'\n",
    "    elif row['DESHABITACION'] >= rangos_deshabitacion_grupo[3]:\n",
    "        return 'd'\n",
    "    else:\n",
    "        return '0'  # Valor predeterminado\n",
    "\n",
    "# Crear un nuevo campo 'R_DESHAB' y llenarlo con las subtipologías asignadas\n",
    "MAPA_TIPO_sumado['R_DESHAB'] = MAPA_TIPO_sumado.apply(asignar_subtipologia, axis=1)\n",
    "\n",
    "# Crear el campo SUBTIPOLOGÍA\n",
    "MAPA_TIPO_sumado['SUBTIPOLOGÍA'] = MAPA_TIPO_sumado['TIPOLOGIA'].astype(str) + '-' + MAPA_TIPO_sumado['R_DESHAB'].astype(str)\n",
    "\n",
    "\n",
    "# Guardar los datos en un archivo Excel\n",
    "MAPA_TIPO_sumado.to_excel('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_municipios.xlsx', index=False)\n",
    "\n",
    "# Leer el archivo Excel\n",
    "wb = openpyxl.load_workbook('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_municipios.xlsx')\n",
    "\n",
    "# Seleccionar la hoja de cálculo\n",
    "sheet = wb.active\n",
    "\n",
    "# Ajustar el ancho de las columnas automáticamente\n",
    "for col in sheet.columns:\n",
    "    max_length = 0\n",
    "    column = col[0].column_letter\n",
    "    for cell in col:\n",
    "        try:\n",
    "            if len(str(cell.value)) > max_length:\n",
    "                max_length = len(cell.value)\n",
    "        except:\n",
    "            pass\n",
    "    adjusted_width = (max_length + 2) * 1.2\n",
    "    sheet.column_dimensions[column].width = adjusted_width\n",
    "\n",
    "# Guardar los cambios en el archivo Excel\n",
    "wb.save('C:/Users/ADMIN/OneDrive - Universidad de Guadalajara/3. Voces/2024/Tipologías/Nacional/resultados_municipios_v2.xlsx')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "be549d1b-757a-4231-bef6-833bb6e13855",
   "metadata": {},
   "source": [
    "<h1>Carga a PostgrSQL</h1>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8a64b4da",
   "metadata": {},
   "outputs": [],
   "source": [
    "MAPA_TIPO_ruta = r\"C:\\Users\\ADMIN\\OneDrive - Universidad de Guadalajara\\3. Voces\\2024\\Tipologías\\Nacional\\Nac_Tipologias.gpkg\"\n",
    "\n",
    "# Leer gpkg base\n",
    "MAPA_TIPO_gdf = gpd.read_file(MAPA_TIPO_ruta, layer='Mapa_Nac_Tipologias')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "2ee47416",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Configuración de la conexión a la base de datos PostGIS\n",
    "nombre_base_datos = 'VOCES'\n",
    "usuario = 'postgres'\n",
    "contraseña = 'admin'\n",
    "host = 'localhost'  # O el host de tu servidor PostgreSQL\n",
    "puerto = '5432'     # El puerto de tu servidor PostgreSQL\n",
    "tabla_destino = 'tipologias_nacional'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "78a4f7fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "import geoalchemy2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "fc9d9853",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Datos subidos a PostGIS en la tabla tipologias_nacional\n"
     ]
    }
   ],
   "source": [
    "# Crear una conexión a la base de datos PostGIS\n",
    "engine = create_engine(f'postgresql://{usuario}:{contraseña}@{host}:{puerto}/{nombre_base_datos}')\n",
    "\n",
    "# Guardar el GeoDataFrame resultante en la tabla de PostGIS\n",
    "MAPA_TIPO_gdf.to_postgis(tabla_destino, engine, if_exists='replace', index=False)\n",
    "\n",
    "print(f\"Datos subidos a PostGIS en la tabla {tabla_destino}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "65076e44",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "celltoolbar": "Raw Cell Format",
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
